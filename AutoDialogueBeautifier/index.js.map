{"version":3,"file":"index.js","mappings":"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","sources":["src://tavern_helper_template/src/自适应正则脚本/index.ts"],"sourcesContent":["// 自适应正则脚本\n// 功能：AI输出完成后，检测最后一层聊天存在的表达式，将匹配的 scriptName 存入变量并排序\n// 加载脚本/变量变化时，检查角色卡正则列表与变量列表，注册缺失的正则\n// 卸载脚本时，根据列表卸载对应的正则\n// 使用防抖机制（500ms）防止无限循环\n\nimport regexData from './regex.json';\n\n$(async () => {\n  console.info('自适应正则脚本已加载');\n\n  // 聊天变量键名 - 存储当前应该注册的正则 scriptName 列表\n  const VARIABLE_KEY = 'adaptive_regex_names';\n\n  // 同步锁，防止无限循环\n  let isSyncing = false;\n  // 上次处理的聊天ID，用于防抖\n  let lastChatId: string | null = null;\n  // 防抖定时器\n  let syncTimeout: ReturnType<typeof setTimeout> | null = null;\n\n  // ========== 缓存机制 ==========\n  // 缓存编译后的正则 patterns，避免每次消息都重新解析\n  let cachedPatterns: { scriptName: string; pattern: RegExp; quickCheck: string }[] | null = null;\n  // 缓存启用的正则规则\n  let cachedEnabledRules: TavernRegex[] | null = null;\n\n  // 清除缓存（用于 regex.json 更新时）\n  const clearCache = (): void => {\n    cachedPatterns = null;\n    cachedEnabledRules = null;\n    console.info('自适应正则: 缓存已清除');\n  };\n\n  console.info(`自适应正则: 成功加载 ${regexData.length} 条规则`);\n\n  // 从 regex.json 中获取有效的正则规则（带缓存）\n  const getEnabledRegexRules = (): TavernRegex[] => {\n    if (cachedEnabledRules !== null) {\n      return cachedEnabledRules;\n    }\n    cachedEnabledRules = regexData\n      .filter((rule: any) => !rule.disabled)\n      .map((rule: any) => ({\n        id: rule.id,\n        script_name: rule.scriptName,\n        enabled: true,\n        scope: 'character' as const,\n        find_regex: rule.findRegex,\n        replace_string: rule.replaceString,\n        trim_strings: Array.isArray(rule.trimStrings) ? rule.trimStrings.join('\\n') : '',\n        source: {\n          user_input: false,\n          ai_output: true,\n          slash_command: false,\n          world_info: false,\n        },\n        destination: {\n          display: true,\n          prompt: false,\n        },\n        run_on_edit: rule.runOnEdit ?? true,\n        min_depth: rule.minDepth ?? null,\n        max_depth: rule.maxDepth ?? 10,\n      }));\n    return cachedEnabledRules;\n  };\n\n  // 从 regex.json 提取检测模式（带缓存，避免每次消息都重新解析）\n  const extractDetectionPatterns = (): { scriptName: string; pattern: RegExp; quickCheck: string }[] => {\n    // 直接返回缓存，避免重复计算\n    if (cachedPatterns !== null) {\n      return cachedPatterns;\n    }\n\n    // 计算并缓存结果\n    const result = regexData\n      .filter((rule: any) => !rule.disabled)\n      .map((rule: any) => {\n        let patternStr = rule.findRegex;\n\n        // 解析正则表达式，去除可能的 /pattern/flags 格式\n        const match = patternStr.match(/^\\/(.+)\\/([gimsuy]*)$/);\n        if (match) {\n          patternStr = match[1];\n        }\n\n        try {\n          const pattern = new RegExp(patternStr, 'i');\n\n          let quickCheck = '';\n          if (patternStr.includes('{') || patternStr.includes('\\\\{')) {\n            quickCheck = '{';\n          } else if (patternStr.includes('<') || patternStr.includes('\\\\<')) {\n            const tagMatch = patternStr.match(/<(\\w+)/);\n            if (tagMatch) {\n              quickCheck = `<${tagMatch[1]}`;\n            }\n          } else if (patternStr.includes('\\\\[') || patternStr.includes('\\\\]')) {\n            quickCheck = '[';\n          } else if (patternStr.includes('\\\\(') || patternStr.includes('\\\\)')) {\n            quickCheck = '(';\n          } else if (patternStr.startsWith('>')) {\n            quickCheck = '>';\n          } else if (patternStr.startsWith('<')) {\n            const firstTagMatch = patternStr.match(/<(\\w+)/);\n            if (firstTagMatch) {\n              quickCheck = `<${firstTagMatch[1]}`;\n            }\n          } else {\n            quickCheck = patternStr.substring(0, Math.min(15, patternStr.length));\n          }\n\n          return {\n            scriptName: rule.scriptName,\n            pattern,\n            quickCheck,\n          };\n        } catch (e) {\n          console.warn(`无效的正则表达式: ${patternStr}`, e);\n          return null;\n        }\n      })\n      .filter(Boolean) as { scriptName: string; pattern: RegExp; quickCheck: string }[];\n\n    // 存入缓存并返回\n    cachedPatterns = result;\n    return result;\n  };\n\n  // 检测消息中包含的需要处理的正则 scriptName\n  // skipStoredNames: 已存储的正则名称列表，跳过这些正则的匹配检测\n  const detectNeededScriptNames = (messageContent: string, skipStoredNames: string[] = []): string[] => {\n    if (!messageContent || messageContent.length < 3) {\n      return [];\n    }\n\n    const patterns = extractDetectionPatterns();\n    const neededNames: string[] = [];\n    const skipSet = new Set(skipStoredNames);\n\n    for (const { scriptName, pattern, quickCheck } of patterns) {\n      // 跳过已存储的正则（它们已经匹配过了，不需要再次检测）\n      if (skipSet.has(scriptName)) {\n        continue;\n      }\n\n      // 快速预检查\n      if (quickCheck && !messageContent.includes(quickCheck)) {\n        continue;\n      }\n\n      try {\n        pattern.lastIndex = 0;\n        if (pattern.test(messageContent)) {\n          neededNames.push(scriptName);\n          console.info(`自适应正则: 检测到 ${scriptName}`);\n        }\n      } catch (e) {\n        // 忽略正则测试错误\n      }\n    }\n\n    return neededNames;\n  };\n\n  // 获取聊天变量中存储的正则名称列表\n  const getStoredRegexNames = (): string[] => {\n    try {\n      const chatVars = getVariables({ type: 'chat' });\n      const stored = chatVars?.[VARIABLE_KEY];\n      if (Array.isArray(stored)) {\n        return stored.filter((item): item is string => typeof item === 'string');\n      }\n    } catch (e) {\n      console.warn('获取存储的正则名称失败:', e);\n    }\n    return [];\n  };\n\n  // 保存正则名称列表到聊天变量（排序后）\n  const saveStoredRegexNames = (names: string[]): void => {\n    try {\n      // 排序保证一致性\n      const sortedNames = [...names].sort();\n      replaceVariables({ [VARIABLE_KEY]: sortedNames }, { type: 'chat' });\n      console.info(`自适应正则: 已保存 ${sortedNames.length} 个正则名称到聊天变量`);\n    } catch (e) {\n      console.warn('保存正则名称失败:', e);\n    }\n  };\n\n  // 获取角色卡当前已注册的所有正则 scriptName\n  const getCharacterCardRegexNames = async (): Promise<Set<string>> => {\n    const names = new Set<string>();\n    try {\n      const regexes = await updateTavernRegexesWith((regexes: TavernRegex[]) => {\n        regexes.forEach(r => names.add(r.script_name));\n        return regexes;\n      });\n    } catch (e) {\n      console.warn('获取角色卡正则列表失败:', e);\n    }\n    return names;\n  };\n\n  // 注册单个正则规则\n  const registerRegexRule = async (rule: TavernRegex): Promise<void> => {\n    try {\n      await updateTavernRegexesWith((regexes: TavernRegex[]) => {\n        // 避免重复注册同名正则\n        const filtered = regexes.filter((r: TavernRegex) => r.script_name !== rule.script_name);\n        return [...filtered, rule];\n      });\n    } catch (e) {\n      console.warn(`注册正则失败: ${rule.script_name}`, e);\n    }\n  };\n\n  // 同步正则列表：对比变量列表和角色卡正则列表\n  // - 移除：存在于角色卡正则列表但不在变量列表中的正则\n  // - 注册：存在于变量列表但不在角色卡正则列表中的正则\n  const syncRegexWithVariable = async (): Promise<void> => {\n    // 防止重复调用\n    if (isSyncing) {\n      console.info('自适应正则: 正在同步中，跳过本次调用');\n      return;\n    }\n\n    try {\n      isSyncing = true;\n\n      const variableNames = getStoredRegexNames();\n      const variableSet = new Set(variableNames);\n      const characterCardNames = await getCharacterCardRegexNames();\n      const characterSet = new Set(characterCardNames);\n\n      // 获取所有启用状态的 regex.json 规则名称（用于判断是否应该移除）\n      const enabledRegexNames = new Set(getEnabledRegexRules().map(r => r.script_name));\n\n      // 找出需要移除的正则（同时满足两个条件：1. 在regex.json中启用 2. 不在变量列表中）\n      const toRemove: string[] = [];\n      for (const name of characterCardNames) {\n        // 只有当该正则是在regex.json中启用着的，且不在变量列表中时才移除\n        if (!variableSet.has(name) && enabledRegexNames.has(name)) {\n          toRemove.push(name);\n        }\n      }\n\n      // 找出需要注册的正则（在变量中但不在角色卡中）\n      const toRegister: string[] = [];\n      for (const name of variableNames) {\n        if (!characterSet.has(name)) {\n          toRegister.push(name);\n        }\n      }\n\n      // 执行移除\n      if (toRemove.length > 0) {\n        await removeRegexByNames(toRemove);\n        console.info(`自适应正则: 已移除 ${toRemove.length} 条不在变量列表中的规则: ${toRemove.join(', ')}`);\n      }\n\n      // 执行注册\n      if (toRegister.length > 0) {\n        const allRules = getEnabledRegexRules();\n        let registeredCount = 0;\n        for (const name of toRegister) {\n          const rule = allRules.find(r => r.script_name === name);\n          if (rule) {\n            await registerRegexRule(rule);\n            registeredCount++;\n            console.info(`自适应正则: 已注册 ${name}`);\n          }\n        }\n        if (registeredCount > 0) {\n          console.info(`自适应正则: 共注册了 ${registeredCount} 条规则`);\n        }\n      }\n\n      if (toRemove.length === 0 && toRegister.length === 0) {\n        console.info('自适应正则: 变量列表与角色卡正则列表已同步，无需更新');\n      }\n    } catch (e) {\n      console.error('同步正则列表失败:', e);\n    } finally {\n      isSyncing = false;\n    }\n  };\n\n  // 移除指定名称的正则\n  const removeRegexByNames = async (names: string[]): Promise<void> => {\n    if (names.length === 0) return;\n\n    try {\n      await updateTavernRegexesWith((regexes: TavernRegex[]) => {\n        return regexes.filter((r: TavernRegex) => !names.includes(r.script_name));\n      });\n      console.info(`自适应正则: 已移除 ${names.length} 条规则`);\n    } catch (e) {\n      console.warn('移除正则失败:', e);\n    }\n  };\n\n  // 扫描最后一层消息并更新变量\n  const scanAndUpdateVariable = async (): Promise<void> => {\n    try {\n      console.info('自适应正则: 开始扫描最后一层消息');\n\n      const messages = getChatMessages(-1); // 获取最后一条消息\n      console.info('自适应正则: 获取到的消息:', messages);\n\n      if (!messages || messages.length === 0) {\n        console.info('自适应正则: 没有找到消息，返回');\n        return;\n      }\n\n      const lastMessage = messages[0];\n      const messageContent = lastMessage.message;\n      console.info('自适应正则: 消息内容:', messageContent);\n\n      // 获取已存储的名称，用于跳过检测\n      const storedNames = getStoredRegexNames();\n      console.info('自适应正则: 已存储的正则名称:', storedNames);\n\n      // 检测需要的正则名称（跳过已存储的正则）\n      const detectedNames = detectNeededScriptNames(messageContent, storedNames);\n      console.info('自适应正则: 检测到的新正则名称:', detectedNames);\n\n      // 合并并去重\n      const combinedNames = [...new Set([...storedNames, ...detectedNames])];\n      console.info('自适应正则: 合并后的正则名称:', combinedNames);\n\n      // 如果有变化，保存并同步\n      const storedSorted = [...storedNames].sort().join(',');\n      const combinedSorted = [...combinedNames].sort().join(',');\n      console.info('自适应正则: 排序后的存储名称:', storedSorted);\n      console.info('自适应正则: 排序后的合并名称:', combinedSorted);\n\n      if (storedSorted !== combinedSorted) {\n        console.info(`自适应正则: 检测到变化，从 ${storedNames.length} 个更新到 ${combinedNames.length} 个`);\n        saveStoredRegexNames(combinedNames);\n        await syncRegexWithVariable();\n      } else {\n        console.info('自适应正则: 无变化，不更新');\n      }\n    } catch (e) {\n      console.error('扫描消息更新变量失败:', e);\n    }\n  };\n\n  // 初始化：根据变量中的列表注册缺失的正则\n  const initializeFromVariable = async (): Promise<void> => {\n    const storedNames = getStoredRegexNames();\n    if (storedNames.length > 0) {\n      console.info(`自适应正则: 初始化，从变量加载 ${storedNames.length} 个正则`);\n      await syncRegexWithVariable();\n    } else {\n      // 如果变量为空，扫描当前消息\n      console.info('自适应正则: 变量为空，扫描当前消息');\n      await scanAndUpdateVariable();\n    }\n  };\n\n  // 监听变量变化的事件回调\n  let previousStoredNames: string[] = [];\n\n  const watchVariableChange = (): void => {\n    // 初始记录\n    previousStoredNames = getStoredRegexNames();\n\n    // 重写 replaceVariables 函数来监听变量变化\n    const originalReplaceVariables = replaceVariables;\n    (window as any).replaceVariables = function (variables: Record<string, any>, option: any) {\n      const result = originalReplaceVariables.call(this, variables, option);\n\n      // 检查是否是聊天变量发生变化，且不在同步中\n      if (!isSyncing && (option?.type === 'chat' || !option)) {\n        const currentStoredNames = getStoredRegexNames();\n        const currentSorted = [...currentStoredNames].sort().join(',');\n        const previousSorted = [...previousStoredNames].sort().join(',');\n\n        if (currentSorted !== previousSorted) {\n          console.info(`自适应正则: 变量发生变化，刷新正则列表`);\n          // 使用防抖，避免频繁触发\n          if (syncTimeout) {\n            clearTimeout(syncTimeout);\n          }\n          syncTimeout = setTimeout(() => {\n            syncRegexWithVariable().then(() => {\n              previousStoredNames = getStoredRegexNames();\n            });\n          }, 500);\n        }\n      }\n\n      return result;\n    };\n  };\n\n  // 监听新消息事件（AI输出完成时）\n  eventOn(tavern_events.MESSAGE_RECEIVED, async (messageId: number) => {\n    console.info(`自适应正则: 收到新消息 ${messageId}，扫描最新楼层`);\n    await scanAndUpdateVariable();\n  });\n\n  // 监听聊天切换事件（带防抖）\n  eventOn(tavern_events.CHAT_CHANGED, async (chatFileName: string) => {\n    console.info(`自适应正则: 检测到聊天切换到 ${chatFileName}`);\n\n    // 忽略相同的聊天ID\n    if (lastChatId === chatFileName) {\n      return;\n    }\n    lastChatId = chatFileName;\n\n    // 清除之前的定时器\n    if (syncTimeout) {\n      clearTimeout(syncTimeout);\n    }\n\n    // 防抖：延迟 500ms 执行同步\n    syncTimeout = setTimeout(async () => {\n      if (!isSyncing) {\n        await syncRegexWithVariable();\n      }\n    }, 500);\n  });\n\n  // 卸载时移除所有本脚本注册的正则\n  $(window).on('pagehide', async () => {\n    const storedNames = getStoredRegexNames();\n    if (storedNames.length > 0) {\n      await removeRegexByNames(storedNames);\n      console.info(`自适应正则: 已卸载 ${storedNames.length} 条规则`);\n    }\n    console.info('自适应正则脚本已卸载');\n  });\n\n  // 启动\n  console.info('自适应正则: 启动初始化');\n  await initializeFromVariable();\n  watchVariableChange();\n\n  const enabledRules = regexData.filter((r: any) => !r.disabled).length;\n  console.info(`自适应正则: 准备了 ${enabledRules} 条规则用于检测`);\n});\n"],"names":["$","async","console","info","VARIABLE_KEY","isSyncing","lastChatId","syncTimeout","cachedPatterns","cachedEnabledRules","length","getEnabledRegexRules","filter","rule","disabled","map","id","script_name","scriptName","enabled","scope","find_regex","findRegex","replace_string","replaceString","trim_strings","Array","isArray","trimStrings","join","source","user_input","ai_output","slash_command","world_info","destination","display","prompt","run_on_edit","runOnEdit","min_depth","minDepth","max_depth","maxDepth","detectNeededScriptNames","messageContent","skipStoredNames","patterns","result","patternStr","match","pattern","RegExp","quickCheck","includes","tagMatch","startsWith","firstTagMatch","substring","Math","min","e","warn","Boolean","extractDetectionPatterns","neededNames","skipSet","Set","has","lastIndex","test","push","getStoredRegexNames","chatVars","getVariables","type","stored","item","registerRegexRule","updateTavernRegexesWith","regexes","r","syncRegexWithVariable","variableNames","variableSet","characterCardNames","names","forEach","add","getCharacterCardRegexNames","characterSet","enabledRegexNames","toRemove","name","toRegister","removeRegexByNames","allRules","registeredCount","find","error","scanAndUpdateVariable","messages","getChatMessages","message","storedNames","detectedNames","combinedNames","storedSorted","sort","combinedSorted","sortedNames","replaceVariables","saveStoredRegexNames","previousStoredNames","eventOn","tavern_events","MESSAGE_RECEIVED","messageId","CHAT_CHANGED","chatFileName","clearTimeout","setTimeout","window","on","initializeFromVariable","originalReplaceVariables","variables","option","call","this","then","watchVariableChange","enabledRules"],"sourceRoot":""}