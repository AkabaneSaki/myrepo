<<<<<<< Updated upstream
{"version":3,"file":"index.js","mappings":"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","sources":["src://tavern_helper_template/src/自适应正则脚本/index.ts"],"sourcesContent":["// 自适应正则脚本\n// 功能：检测AI输出聊天中存在表达式内容时，自动注册相应的正则规则\n// 卸载时自动移除所有其注册的正则\n// 性能优化：缓存检测模式、延迟执行，防抖、跳过已注册规则\n\nimport regexData from './regex.json';\n\n$(async () => {\n  console.info('自适应正则脚本已加载');\n\n  // ===== 优化1: 使用 Set 替代数组存储已注册ID (O(1) 查找) =====\n  const registeredRegexIds = new Set<string>();\n\n  // ===== 优化2: 缓存解析结果 =====\n  // 缓存提取的检测模式和预检查标记\n  let cachedPatterns: { id: string; pattern: RegExp; name: string; quickCheck: string }[] | null = null;\n  // 缓存转换后的酒馆正则规则\n  let cachedTavernRules: TavernRegex[] | null = null;\n\n  // 解析正则数据，转换为酒馆正则格式（带缓存）\n  const parseRegexRules = (): TavernRegex[] => {\n    if (cachedTavernRules) {\n      return cachedTavernRules;\n    }\n\n    cachedTavernRules = regexData\n      .filter((rule: any) => !rule.disabled)\n      .map((rule: any) => ({\n        id: rule.id,\n        script_name: rule.scriptName,\n        enabled: true,\n        scope: 'character' as const,\n        find_regex: rule.findRegex,\n        replace_string: rule.replaceString,\n        trim_strings: Array.isArray(rule.trimStrings) ? rule.trimStrings.join('\\n') : '',\n        source: {\n          user_input: false,\n          ai_output: true,\n          slash_command: false,\n          world_info: false,\n        },\n        destination: {\n          display: true,\n          prompt: false,\n        },\n        run_on_edit: rule.runOnEdit ?? true,\n        min_depth: rule.minDepth ?? null,\n        max_depth: rule.maxDepth ?? 10,\n      }));\n\n    return cachedTavernRules;\n  };\n\n  // 从正则规则中提取检测模式（带缓存）\n  const extractDetectionPatterns = (): { id: string; pattern: RegExp; name: string; quickCheck: string }[] => {\n    if (cachedPatterns) {\n      return cachedPatterns;\n    }\n\n    cachedPatterns = regexData\n      .filter((rule: any) => !rule.disabled)\n      .map((rule: any) => {\n        // 清理正则表达式\n        let patternStr = rule.findRegex;\n        const match = patternStr.match(/^\\/(.+)\\/([gimsuy]*)$/);\n        if (match) {\n          patternStr = match[1];\n        }\n\n        // 尝试创建正则\n        try {\n          const pattern = new RegExp(patternStr, 'i');\n\n          // ===== 优化3: 改进快速检查字符串提取 =====\n          let quickCheck = '';\n          // 优先提取正则中的特殊字符或结构化标记\n          if (patternStr.includes('{') || patternStr.includes('\\\\{')) {\n            quickCheck = '{';\n          } else if (patternStr.includes('<') || patternStr.includes('\\\\<')) {\n            const tagMatch = patternStr.match(/<(\\w+)/);\n            if (tagMatch) {\n              quickCheck = `<${tagMatch[1]}`;\n            }\n          } else if (patternStr.includes('\\\\[') || patternStr.includes('\\\\]')) {\n            quickCheck = '[';\n          } else if (patternStr.includes('\\\\(') || patternStr.includes('\\\\)')) {\n            quickCheck = '(';\n          } else if (patternStr.startsWith('>')) {\n            // 中文冒号格式\n            quickCheck = '>';\n          } else if (patternStr.startsWith('<')) {\n            // 标签格式\n            const firstTagMatch = patternStr.match(/<(\\w+)/);\n            if (firstTagMatch) {\n              quickCheck = `<${firstTagMatch[1]}`;\n            }\n          } else {\n            // 使用正则的前15个字符作为快速检查\n            quickCheck = patternStr.substring(0, Math.min(15, patternStr.length));\n          }\n\n          return {\n            id: rule.id,\n            pattern,\n            name: rule.scriptName,\n            quickCheck,\n          };\n        } catch (e) {\n          console.warn(`无效的正则表达式: ${patternStr}`, e);\n          return null;\n        }\n      })\n      .filter(Boolean) as { id: string; pattern: RegExp; name: string; quickCheck: string }[];\n\n    return cachedPatterns;\n  };\n\n  // ===== 优化10: 酒馆正则已注册名称缓存 =====\n  const existingRegexNames = new Set<string>();\n\n  // ===== 聊天变量键名 =====\n  const CHAT_VAR_KEY = '自适应正则_已注册列表';\n\n  // ===== 优化: 跟踪每个消息的最后检测时间 =====\n  const messageLastDetectTime = new Map<number, number>();\n  const DETECT_COOLDOWN = 2000; // 2秒内不重复检测同一消息\n\n  // 从聊天变量加载已注册的正则名称\n  const loadRegisteredRegexesFromChat = (): string[] => {\n    try {\n      const chatVars = getVariables({ type: 'chat' });\n      const registered = chatVars?.[CHAT_VAR_KEY];\n      if (Array.isArray(registered)) {\n        return registered.filter((item): item is string => typeof item === 'string');\n      }\n    } catch (e) {\n      // 忽略读取错误\n    }\n    return [];\n  };\n\n  // 保存已注册的正则名称到聊天变量\n  const saveRegisteredRegexesToChat = (names: string[]) => {\n    try {\n      replaceVariables({ [CHAT_VAR_KEY]: names }, { type: 'chat' });\n    } catch (e) {\n      // 忽略保存错误\n    }\n  };\n\n  // 初始化时获取已存在的正则名称（从酒馆和聊天变量）\n  const initExistingRegexes = async () => {\n    try {\n      // 1. 获取酒馆中已存在的正则名称\n      await window.TavernHelper.updateTavernRegexesWith((regexes: TavernRegex[]) => {\n        regexes.forEach(r => existingRegexNames.add(r.script_name));\n        return regexes;\n      });\n\n      // 2. 从聊天变量加载已注册的正则名称（用于跨会话保持）\n      const savedNames = loadRegisteredRegexesFromChat();\n      savedNames.forEach(name => existingRegexNames.add(name));\n      console.info(`自适应正则: 从聊天变量恢复了 ${savedNames.length} 条已注册正则`);\n    } catch (e) {\n      // 忽略初始化错误\n    }\n  };\n\n  // 检测消息中是否包含需要处理的表达式（带快速预检查）\n  const detectNeededRegexes = (messageContent: string): string[] => {\n    // 消息长度预检\n    if (!messageContent || messageContent.length < 3) {\n      return [];\n    }\n\n    // ===== 优化: 如果所有正则都已注册，直接返回空 =====\n    const patterns = extractDetectionPatterns();\n    if (registeredRegexIds.size >= patterns.length) {\n      return [];\n    }\n\n    const neededIds: string[] = [];\n\n    for (const { id, pattern, name, quickCheck } of patterns) {\n      // 优化5: 使用 Set 的 has 方法 O(1) 查找 - 跳过内存中已注册的正则\n      if (registeredRegexIds.has(id)) {\n        continue;\n      }\n\n      // 优化10: 跳过酒馆中已存在的同名正则（可能有其他脚本注册）\n      if (existingRegexNames.has(name)) {\n        registeredRegexIds.add(id); // 标记为已处理，避免重复检测\n        continue;\n      }\n\n      // 快速预检查\n      if (quickCheck && !messageContent.includes(quickCheck)) {\n        continue;\n      }\n\n      try {\n        pattern.lastIndex = 0;\n        if (pattern.test(messageContent)) {\n          neededIds.push(id);\n          console.info(`自适应正则: 检测到 ${name}，准备注册`);\n        }\n      } catch (e) {\n        // 忽略正则测试错误\n      }\n    }\n\n    return neededIds;\n  };\n\n  // ===== 优化7: 批量处理函数 =====\n  let debounceTimer: ReturnType<typeof setTimeout> | null = null;\n  const pendingMessageIds = new Set<number>();\n\n  const processMessageQueue = async () => {\n    if (pendingMessageIds.size === 0) return;\n\n    const messageIds = Array.from(pendingMessageIds);\n    pendingMessageIds.clear();\n\n    // 收集所有待注册的正则ID\n    const allNeededIds = new Set<string>();\n\n    for (const message_id of messageIds) {\n      try {\n        // ===== 优化8: 直接获取消息内容而非遍历 =====\n        const messages = getChatMessages(message_id);\n        if (!messages || messages.length === 0) continue;\n\n        const messageContent = messages[0].message;\n        const neededIds = detectNeededRegexes(messageContent);\n        neededIds.forEach(id => allNeededIds.add(id));\n      } catch (error) {\n        console.error('自适应正则处理出错:', error);\n      }\n    }\n\n    // 批量注册所有需要的正则\n    if (allNeededIds.size > 0) {\n      await registerMultipleRegexes(Array.from(allNeededIds));\n    }\n  };\n\n  // 防抖包装函数\n  const debouncedProcess = (message_id: number) => {\n    // ===== 优化: 冷却时间检查，避免快速重复处理同一消息 =====\n    const now = Date.now();\n    const lastDetect = messageLastDetectTime.get(message_id) || 0;\n    if (now - lastDetect < DETECT_COOLDOWN) {\n      return; // 2秒内不重复处理\n    }\n    messageLastDetectTime.set(message_id, now);\n\n    pendingMessageIds.add(message_id);\n\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n    }\n\n    // 150ms 防抖延迟\n    debounceTimer = setTimeout(() => {\n      processMessageQueue();\n    }, 150);\n  };\n\n  // 注册单个正则规则（内部使用）\n  const registerSingleRegex = (regex: TavernRegex): boolean => {\n    if (registeredRegexIds.has(regex.id)) {\n      return false; // 已经注册过了\n    }\n\n    registeredRegexIds.add(regex.id);\n    return true;\n  };\n\n  // ===== 优化9: 批量注册 - 减少 await 调用次数 =====\n  const registerMultipleRegexes = async (ids: string[]): Promise<void> => {\n    const allRules = parseRegexRules();\n    const rulesToRegister: TavernRegex[] = [];\n\n    for (const id of ids) {\n      const rule = allRules.find((r: TavernRegex) => r.id === id);\n      if (rule && registerSingleRegex(rule)) {\n        rulesToRegister.push(rule);\n      }\n    }\n\n    if (rulesToRegister.length === 0) return;\n\n    // 获取已存在的正则，合并后一次性更新\n    await window.TavernHelper.updateTavernRegexesWith((regexes: TavernRegex[]) => {\n      // 移除可能存在的同名正则\n      const registeredNames = rulesToRegister.map(r => r.script_name);\n      const filtered = regexes.filter((r: TavernRegex) => !registeredNames.includes(r.script_name));\n      return [...filtered, ...rulesToRegister];\n    });\n\n    // 保存到聊天变量，便于下次加载时恢复\n    const allRegisteredNames = [...loadRegisteredRegexesFromChat(), ...rulesToRegister.map(r => r.script_name)];\n    // 去重\n    const uniqueNames = [...new Set(allRegisteredNames)];\n    saveRegisteredRegexesToChat(uniqueNames);\n\n    console.info(`自适应正则: 已批量注册 ${rulesToRegister.length} 条规则，并保存到聊天变量`);\n  };\n\n  // 移除所有已注册的正则\n  const unregisterAllRegexes = async (): Promise<void> => {\n    if (registeredRegexIds.size === 0) {\n      return;\n    }\n\n    const allRules = parseRegexRules();\n    const registeredNames = Array.from(registeredRegexIds)\n      .map(id => allRules.find((r: TavernRegex) => r.id === id)?.script_name)\n      .filter(Boolean) as string[];\n\n    await window.TavernHelper.updateTavernRegexesWith((regexes: TavernRegex[]) => {\n      return regexes.filter((r: TavernRegex) => !registeredNames.includes(r.script_name));\n    });\n\n    console.info(`自适应正则: 已移除 ${registeredNames.length} 条规则`);\n    registeredRegexIds.clear();\n  };\n\n  // ===== 优化: 跟踪已处理的消息ID，避免重复处理 =====\n  const processedMessageIds = new Set<number>();\n\n  // 监听消息接收事件\n  eventOn(tavern_events.MESSAGE_RECEIVED, async (message_id: number) => {\n    // 只处理之前未处理过的消息\n    if (!processedMessageIds.has(message_id)) {\n      processedMessageIds.add(message_id);\n      debouncedProcess(message_id);\n    }\n  });\n\n  // 监听消息编辑事件 - 已禁用，因为会导致频繁刷新\n\n  // ===== 监听聊天切换事件 =====\n  // 使用一个标志来防止在同步过程中重复触发\n  let isSyncingChat = false;\n  eventOn(tavern_events.CHAT_CHANGED, async (chat_file_name: string) => {\n    // 防止重复触发\n    if (isSyncingChat) {\n      console.info('自适应正则: 正在同步中，跳过此次触发');\n      return;\n    }\n    isSyncingChat = true;\n\n    console.info(`自适应正则: 聊天切换到 ${chat_file_name}，开始同步正则状态`);\n\n    // 获取聊天变量中记录的已注册正则名称\n    const savedNames = loadRegisteredRegexesFromChat();\n    console.info(`自适应正则: 聊天变量中有 ${savedNames.length} 条已注册正则`);\n\n    try {\n      // 获取当前酒馆中实际已注册的正则\n      const allRules = parseRegexRules();\n      let actualRegisteredNames: string[] = [];\n\n      await window.TavernHelper.updateTavernRegexesWith((regexes: TavernRegex[]) => {\n        actualRegisteredNames = regexes.filter(r => savedNames.includes(r.script_name)).map(r => r.script_name);\n        return regexes;\n      });\n\n      console.info(`自适应正则: 酒馆中实际有 ${actualRegisteredNames.length} 条正则`);\n\n      // 需要重新注册的（变量中有但正则中没有）\n      const toReRegister = savedNames.filter(name => !actualRegisteredNames.includes(name));\n      // 需要移除的（变量中没有但正则中有）- 这里不需要主动移除，因为脚本会在卸载时清理\n\n      if (toReRegister.length > 0) {\n        console.info(`自适应正则: 需要重新注册 ${toReRegister.length} 条正则: ${toReRegister.join(', ')}`);\n        // 重新注册缺失的正则\n        const rulesToReRegister = allRules.filter((r: TavernRegex) => toReRegister.includes(r.script_name));\n        if (rulesToReRegister.length > 0) {\n          await window.TavernHelper.updateTavernRegexesWith((regexes: TavernRegex[]) => {\n            const registeredNames = rulesToReRegister.map(r => r.script_name);\n            const filtered = regexes.filter((r: TavernRegex) => !registeredNames.includes(r.script_name));\n            return [...filtered, ...rulesToReRegister];\n          });\n          console.info(`自适应正则: 已重新注册 ${rulesToReRegister.length} 条规则`);\n        }\n      }\n\n      // 将实际注册的名称同步到 existingRegexNames 缓存\n      actualRegisteredNames.forEach(name => existingRegexNames.add(name));\n      toReRegister.forEach(name => existingRegexNames.add(name));\n    } catch (error) {\n      console.error('自适应正则: 聊天切换时同步出错:', error);\n    }\n\n    // 检测最新消息 - 已禁用，因为新消息会有 MESSAGE_RECEIVED 事件处理\n    // try {\n    //   const lastMessageId = getLastMessageId();\n    //   if (lastMessageId >= 0) {\n    //     const messages = getChatMessages(lastMessageId);\n    //     if (messages && messages.length > 0) {\n    //       const msg = messages[0];\n    //       if (msg?.message_id !== undefined) {\n    //         debouncedProcess(msg.message_id);\n    //       }\n    //     }\n    //   }\n    // } catch (error) {\n    //   console.error('自适应正则: 检测最新消息出错:', error);\n    // }\n\n    // 重置同步标志\n    isSyncingChat = false;\n\n    // ===== 优化: 聊天切换时清空已处理消息列表 =====\n    processedMessageIds.clear();\n    messageLastDetectTime.clear();\n  });\n\n  const enabledRules = regexData.filter((r: any) => !r.disabled).length;\n  console.info(`自适应正则: 准备了 ${enabledRules} 条规则用于检测`);\n\n  // ===== 优化10: 初始化时获取酒馆中已存在的正则 =====\n  await initExistingRegexes();\n\n  // 卸载时移除所有已注册的正则\n  $(window).on('pagehide', async () => {\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n    }\n    await processMessageQueue();\n    await unregisterAllRegexes();\n    console.info('自适应正则脚本已卸载');\n  });\n});\n"],"names":["$","async","console","info","registeredRegexIds","Set","cachedPatterns","cachedTavernRules","parseRegexRules","filter","rule","disabled","map","id","script_name","scriptName","enabled","scope","find_regex","findRegex","replace_string","replaceString","trim_strings","Array","isArray","trimStrings","join","source","user_input","ai_output","slash_command","world_info","destination","display","prompt","run_on_edit","runOnEdit","min_depth","minDepth","max_depth","maxDepth","existingRegexNames","CHAT_VAR_KEY","messageLastDetectTime","Map","loadRegisteredRegexesFromChat","chatVars","getVariables","type","registered","item","e","detectNeededRegexes","messageContent","length","patterns","patternStr","match","pattern","RegExp","quickCheck","includes","tagMatch","startsWith","firstTagMatch","substring","Math","min","name","warn","Boolean","size","neededIds","has","add","lastIndex","test","push","debounceTimer","pendingMessageIds","processMessageQueue","messageIds","from","clear","allNeededIds","message_id","messages","getChatMessages","message","forEach","error","registerMultipleRegexes","registerSingleRegex","regex","ids","allRules","rulesToRegister","find","r","window","TavernHelper","updateTavernRegexesWith","regexes","registeredNames","allRegisteredNames","names","replaceVariables","saveRegisteredRegexesToChat","processedMessageIds","eventOn","tavern_events","MESSAGE_RECEIVED","now","Date","get","set","clearTimeout","setTimeout","debouncedProcess","isSyncingChat","CHAT_CHANGED","chat_file_name","savedNames","actualRegisteredNames","toReRegister","rulesToReRegister","enabledRules","initExistingRegexes","on","unregisterAllRegexes"],"sourceRoot":""}
=======
{"version":3,"file":"index.js","mappings":"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","sources":["src://tavern_helper_template/src/自适应正则脚本/index.ts"],"sourcesContent":["// 自适应正则脚本\n// 功能：检测AI输出聊天中存在表达式内容时，自动注册相应的正则规则\n// 卸载时自动移除所有其注册的正则\n// 使用聊天变量来记录已注册的正则ID缓存\n\nimport regexData from './regex.json';\n\n$(async () => {\n  console.info('自适应正则脚本已加载');\n\n  // 聊天变量键名\n  const CACHE_KEY = 'registered_regex_ids';\n\n  // 获取缓存的已注册正则ID\n  const getCachedRegexIds = (): Set<string> => {\n    try {\n      const cached = getVariables({ type: 'chat' });\n      const ids = cached?.[CACHE_KEY];\n      if (Array.isArray(ids)) {\n        return new Set(ids);\n      }\n    } catch (e) {\n      console.warn('获取缓存的正则ID失败:', e);\n    }\n    return new Set();\n  };\n\n  // 保存已注册的正则ID到聊天变量\n  const saveCachedRegexIds = (ids: Set<string>): void => {\n    try {\n      replaceVariables({ [CACHE_KEY]: Array.from(ids) }, { type: 'chat' });\n    } catch (e) {\n      console.warn('保存正则ID缓存失败:', e);\n    }\n  };\n\n  // 解析正则规则\n  const parseRegexRules = (): TavernRegex[] => {\n    return regexData\n      .filter((rule: any) => !rule.disabled)\n      .map((rule: any) => ({\n        id: rule.id,\n        script_name: rule.scriptName,\n        enabled: true,\n        scope: 'character' as const,\n        find_regex: rule.findRegex,\n        replace_string: rule.replaceString,\n        trim_strings: Array.isArray(rule.trimStrings) ? rule.trimStrings.join('\\n') : '',\n        source: {\n          user_input: false,\n          ai_output: true,\n          slash_command: false,\n          world_info: false,\n        },\n        destination: {\n          display: true,\n          prompt: false,\n        },\n        run_on_edit: rule.runOnEdit ?? true,\n        min_depth: rule.minDepth ?? null,\n        max_depth: rule.maxDepth ?? 10,\n      }));\n  };\n\n  // 提取检测模式\n  const extractDetectionPatterns = (): { id: string; pattern: RegExp; name: string; quickCheck: string }[] => {\n    return regexData\n      .filter((rule: any) => !rule.disabled)\n      .map((rule: any) => {\n        let patternStr = rule.findRegex;\n        const match = patternStr.match(/^\\/(.+)\\/([gimsuy]*)$/);\n        if (match) {\n          patternStr = match[1];\n        }\n\n        try {\n          const pattern = new RegExp(patternStr, 'i');\n\n          let quickCheck = '';\n          if (patternStr.includes('{') || patternStr.includes('\\\\{')) {\n            quickCheck = '{';\n          } else if (patternStr.includes('<') || patternStr.includes('\\\\<')) {\n            const tagMatch = patternStr.match(/<(\\w+)/);\n            if (tagMatch) {\n              quickCheck = `<${tagMatch[1]}`;\n            }\n          } else if (patternStr.includes('\\\\[') || patternStr.includes('\\\\]')) {\n            quickCheck = '[';\n          } else if (patternStr.includes('\\\\(') || patternStr.includes('\\\\)')) {\n            quickCheck = '(';\n          } else if (patternStr.startsWith('>')) {\n            quickCheck = '>';\n          } else if (patternStr.startsWith('<')) {\n            const firstTagMatch = patternStr.match(/<(\\w+)/);\n            if (firstTagMatch) {\n              quickCheck = `<${firstTagMatch[1]}`;\n            }\n          } else {\n            quickCheck = patternStr.substring(0, Math.min(15, patternStr.length));\n          }\n\n          return {\n            id: rule.id,\n            pattern,\n            name: rule.scriptName,\n            quickCheck,\n          };\n        } catch (e) {\n          console.warn(`无效的正则表达式: ${patternStr}`, e);\n          return null;\n        }\n      })\n      .filter(Boolean) as { id: string; pattern: RegExp; name: string; quickCheck: string }[];\n  };\n\n  // 已存在的正则名称缓存\n  const existingRegexNames = new Set<string>();\n\n  // 检测消息中是否包含需要处理的表达式\n  const detectNeededRegexes = (messageContent: string, registeredRegexIds: Set<string>): string[] => {\n    if (!messageContent || messageContent.length < 3) {\n      return [];\n    }\n\n    // 如果所有正则都已注册，直接返回空\n    const patterns = extractDetectionPatterns();\n    if (registeredRegexIds.size >= patterns.length) {\n      return [];\n    }\n\n    const neededIds: string[] = [];\n\n    for (const { id, pattern, name, quickCheck } of patterns) {\n      // 跳过已注册的正则\n      if (registeredRegexIds.has(id)) {\n        continue;\n      }\n\n      // 跳过酒馆中已存在的同名正则\n      if (existingRegexNames.has(name)) {\n        registeredRegexIds.add(id);\n        continue;\n      }\n\n      // 快速预检查\n      if (quickCheck && !messageContent.includes(quickCheck)) {\n        continue;\n      }\n\n      try {\n        pattern.lastIndex = 0;\n        if (pattern.test(messageContent)) {\n          neededIds.push(id);\n          console.info(`自适应正则: 检测到 ${name}，准备注册`);\n        }\n      } catch (e) {\n        // 忽略正则测试错误\n      }\n    }\n\n    return neededIds;\n  };\n\n  // 批量注册正则\n  const registerMultipleRegexes = async (ids: string[], registeredRegexIds: Set<string>): Promise<void> => {\n    if (ids.length === 0) return;\n\n    const allRules = parseRegexRules();\n    const rulesToRegister: TavernRegex[] = [];\n\n    for (const id of ids) {\n      const rule = allRules.find((r: TavernRegex) => r.id === id);\n      if (rule && !registeredRegexIds.has(rule.id)) {\n        registeredRegexIds.add(rule.id);\n        rulesToRegister.push(rule);\n      }\n    }\n\n    if (rulesToRegister.length === 0) return;\n\n    // 批量更新酒馆正则\n    await window.TavernHelper.updateTavernRegexesWith((regexes: TavernRegex[]) => {\n      const registeredNames = rulesToRegister.map(r => r.script_name);\n      const filtered = regexes.filter((r: TavernRegex) => !registeredNames.includes(r.script_name));\n      return [...filtered, ...rulesToRegister];\n    });\n\n    // 保存到缓存\n    saveCachedRegexIds(registeredRegexIds);\n\n    console.info(`自适应正则: 已批量注册 ${rulesToRegister.length} 条规则`);\n  };\n\n  // 处理消息\n  const processMessage = async (messageId: number): Promise<void> => {\n    try {\n      const messages = getChatMessages(messageId);\n      if (!messages || messages.length === 0) return;\n\n      const messageContent = messages[0].message;\n      const registeredRegexIds = getCachedRegexIds();\n      const neededIds = detectNeededRegexes(messageContent, registeredRegexIds);\n\n      if (neededIds.length > 0) {\n        await registerMultipleRegexes(neededIds, registeredRegexIds);\n      }\n    } catch (error) {\n      console.error('自适应正则处理出错:', error);\n    }\n  };\n\n  // 监听消息接收事件\n  eventOn(tavern_events.MESSAGE_RECEIVED, async (messageId: number) => {\n    await processMessage(messageId);\n  });\n\n  // 监听消息编辑事件\n  eventOn(tavern_events.MESSAGE_EDITED, async (messageId: number) => {\n    await processMessage(messageId);\n  });\n\n  // 切换聊天时检查缓存与实际正则的差异（带防抖）\n  let syncTimeout: ReturnType<typeof setTimeout> | null = null;\n  let lastChatId: string | null = null;\n\n  const syncRegexOnChatChange = async (newChatId: string): Promise<void> => {\n    // 忽略相同的聊天ID\n    if (lastChatId === newChatId) return;\n    lastChatId = newChatId;\n\n    // 防抖：延迟执行，避免频繁触发\n    if (syncTimeout) {\n      clearTimeout(syncTimeout);\n    }\n\n    syncTimeout = setTimeout(async () => {\n      try {\n        const cachedIds = getCachedRegexIds();\n        const allRules = parseRegexRules();\n\n        // 获取当前酒馆中已注册的正则\n        const currentRegexNames = new Set<string>();\n        await window.TavernHelper.updateTavernRegexesWith((regexes: TavernRegex[]) => {\n          regexes.forEach(r => currentRegexNames.add(r.script_name));\n          return regexes;\n        });\n\n        // 需要移除的：缓存中有但正则已不存在的（通过检查规则是否存在）\n        const toRemove: string[] = [];\n        for (const id of cachedIds) {\n          const rule = allRules.find(r => r.id === id);\n          if (!rule) {\n            // 规则已不存在于配置中\n            toRemove.push(id);\n          } else if (!currentRegexNames.has(rule.script_name)) {\n            // 规则存在但未在酒馆中注册（可能被其他方式删除了）\n            toRemove.push(id);\n          }\n        }\n\n        // 需要重新注册的：缓存中有ID，但酒馆中实际没有注册对应的正则\n        const toReregister: string[] = [];\n        for (const id of cachedIds) {\n          if (toRemove.includes(id)) continue;\n\n          const rule = allRules.find(r => r.id === id);\n          if (rule && !currentRegexNames.has(rule.script_name)) {\n            toReregister.push(id);\n          }\n        }\n\n        // 执行移除\n        if (toRemove.length > 0) {\n          const removeNames = toRemove\n            .map(id => allRules.find(r => r.id === id)?.script_name)\n            .filter(Boolean) as string[];\n\n          if (removeNames.length > 0) {\n            await window.TavernHelper.updateTavernRegexesWith((regexes: TavernRegex[]) => {\n              return regexes.filter((r: TavernRegex) => !removeNames.includes(r.script_name));\n            });\n            console.info(`自适应正则: 移除了 ${removeNames.length} 条不存在的规则`);\n          }\n\n          // 更新缓存\n          toRemove.forEach(id => cachedIds.delete(id));\n        }\n\n        // 执行重新注册\n        if (toReregister.length > 0) {\n          await registerMultipleRegexes(toReregister, cachedIds);\n          console.info(`自适应正则: 重新注册了 ${toReregister.length} 条规则`);\n        }\n\n        console.info(`自适应正则: 聊天切换同步完成，缓存 ${cachedIds.size} 条规则`);\n      } catch (error) {\n        console.error('自适应正则聊天切换同步出错:', error);\n      }\n    }, 500); // 500ms 防抖延迟\n  };\n\n  // 监听聊天切换事件\n  eventOn(tavern_events.CHAT_CHANGED, async (newChatId: string) => {\n    console.info(`自适应正则: 检测到聊天切换到 ${newChatId}`);\n    await syncRegexOnChatChange(newChatId);\n  });\n\n  const enabledRules = regexData.filter((r: any) => !r.disabled).length;\n  console.info(`自适应正则: 准备了 ${enabledRules} 条规则用于检测`);\n\n  // 初始化时获取酒馆中已存在的正则，并同步缓存\n  await (async () => {\n    try {\n      await window.TavernHelper.updateTavernRegexesWith((regexes: TavernRegex[]) => {\n        regexes.forEach(r => existingRegexNames.add(r.script_name));\n        return regexes;\n      });\n\n      // 首次加载时同步一次缓存\n      await syncRegexOnChatChange(SillyTavern.getCurrentChatId());\n    } catch (e) {\n      // 忽略初始化错误\n    }\n  })();\n\n  // 卸载时移除所有已注册的正则\n  $(window).on('pagehide', async () => {\n    await (async () => {\n      // 获取当前缓存\n      const registeredRegexIds = getCachedRegexIds();\n      if (registeredRegexIds.size === 0) return;\n\n      const allRules = parseRegexRules();\n      const registeredNames = Array.from(registeredRegexIds)\n        .map(id => allRules.find((r: TavernRegex) => r.id === id)?.script_name)\n        .filter(Boolean) as string[];\n\n      await window.TavernHelper.updateTavernRegexesWith((regexes: TavernRegex[]) => {\n        return regexes.filter((r: TavernRegex) => !registeredNames.includes(r.script_name));\n      });\n\n      console.info(`自适应正则: 已移除 ${registeredNames.length} 条规则`);\n\n      // 清除缓存\n      saveCachedRegexIds(new Set());\n    })();\n    console.info('自适应正则脚本已卸载');\n  });\n});\n"],"names":["$","async","console","info","CACHE_KEY","getCachedRegexIds","cached","getVariables","type","ids","Array","isArray","Set","e","warn","saveCachedRegexIds","replaceVariables","from","parseRegexRules","filter","rule","disabled","map","id","script_name","scriptName","enabled","scope","find_regex","findRegex","replace_string","replaceString","trim_strings","trimStrings","join","source","user_input","ai_output","slash_command","world_info","destination","display","prompt","run_on_edit","runOnEdit","min_depth","minDepth","max_depth","maxDepth","existingRegexNames","detectNeededRegexes","messageContent","registeredRegexIds","length","patterns","patternStr","match","pattern","RegExp","quickCheck","includes","tagMatch","startsWith","firstTagMatch","substring","Math","min","name","Boolean","size","neededIds","has","add","lastIndex","test","push","registerMultipleRegexes","allRules","rulesToRegister","find","r","window","TavernHelper","updateTavernRegexesWith","regexes","registeredNames","processMessage","messageId","messages","getChatMessages","message","error","eventOn","tavern_events","MESSAGE_RECEIVED","MESSAGE_EDITED","syncTimeout","lastChatId","syncRegexOnChatChange","newChatId","clearTimeout","setTimeout","cachedIds","currentRegexNames","forEach","toRemove","toReregister","removeNames","delete","CHAT_CHANGED","enabledRules","SillyTavern","getCurrentChatId","on"],"sourceRoot":""}
>>>>>>> Stashed changes
