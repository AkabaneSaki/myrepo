{"version":3,"file":"index.js","mappings":"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","sources":["src://tavern_helper_template/src/自适应正则脚本/index.ts"],"sourcesContent":["// 自适应正则脚本\n// 功能：检测AI输出聊天中存在表达式内容时，自动注册相应的正则规则\n// 卸载时自动移除所有其注册的正则\n// 性能优化：缓存检测模式、延迟执行，防抖、跳过已注册规则\n\nimport regexData from './regex.json';\n\n$(async () => {\n  console.info('自适应正则脚本已加载');\n\n  // ===== 优化1: 使用 Set 替代数组存储已注册ID (O(1) 查找) =====\n  const registeredRegexIds = new Set<string>();\n\n  // ===== 优化2: 缓存解析结果 =====\n  // 缓存提取的检测模式和预检查标记\n  let cachedPatterns: { id: string; pattern: RegExp; name: string; quickCheck: string }[] | null = null;\n  // 缓存转换后的酒馆正则规则\n  let cachedTavernRules: TavernRegex[] | null = null;\n\n  // 解析正则数据，转换为酒馆正则格式（带缓存）\n  const parseRegexRules = (): TavernRegex[] => {\n    if (cachedTavernRules) {\n      return cachedTavernRules;\n    }\n\n    cachedTavernRules = regexData\n      .filter((rule: any) => !rule.disabled)\n      .map((rule: any) => ({\n        id: rule.id,\n        script_name: rule.scriptName,\n        enabled: true,\n        scope: 'global' as const,\n        find_regex: rule.findRegex,\n        replace_string: rule.replaceString,\n        trim_strings: Array.isArray(rule.trimStrings) ? rule.trimStrings.join('\\n') : '',\n        source: {\n          user_input: false,\n          ai_output: true,\n          slash_command: false,\n          world_info: false,\n        },\n        destination: {\n          display: true,\n          prompt: false,\n        },\n        run_on_edit: rule.runOnEdit ?? true,\n        min_depth: rule.minDepth ?? null,\n        max_depth: rule.maxDepth ?? 10,\n      }));\n\n    return cachedTavernRules;\n  };\n\n  // 从正则规则中提取检测模式（带缓存）\n  const extractDetectionPatterns = (): { id: string; pattern: RegExp; name: string; quickCheck: string }[] => {\n    if (cachedPatterns) {\n      return cachedPatterns;\n    }\n\n    cachedPatterns = regexData\n      .filter((rule: any) => !rule.disabled)\n      .map((rule: any) => {\n        // 清理正则表达式\n        let patternStr = rule.findRegex;\n        const match = patternStr.match(/^\\/(.+)\\/([gimsuy]*)$/);\n        if (match) {\n          patternStr = match[1];\n        }\n\n        // 尝试创建正则\n        try {\n          const pattern = new RegExp(patternStr, 'i');\n\n          // ===== 优化3: 改进快速检查字符串提取 =====\n          let quickCheck = '';\n          // 优先提取正则中的特殊字符或结构化标记\n          if (patternStr.includes('{') || patternStr.includes('\\\\{')) {\n            quickCheck = '{';\n          } else if (patternStr.includes('<') || patternStr.includes('\\\\<')) {\n            const tagMatch = patternStr.match(/<(\\w+)/);\n            if (tagMatch) {\n              quickCheck = `<${tagMatch[1]}`;\n            }\n          } else if (patternStr.includes('\\\\[') || patternStr.includes('\\\\]')) {\n            quickCheck = '[';\n          } else if (patternStr.includes('\\\\(') || patternStr.includes('\\\\)')) {\n            quickCheck = '(';\n          } else if (patternStr.startsWith('>')) {\n            // 中文冒号格式\n            quickCheck = '>';\n          } else if (patternStr.startsWith('<')) {\n            // 标签格式\n            const firstTagMatch = patternStr.match(/<(\\w+)/);\n            if (firstTagMatch) {\n              quickCheck = `<${firstTagMatch[1]}`;\n            }\n          } else {\n            // 使用正则的前15个字符作为快速检查\n            quickCheck = patternStr.substring(0, Math.min(15, patternStr.length));\n          }\n\n          return {\n            id: rule.id,\n            pattern,\n            name: rule.scriptName,\n            quickCheck,\n          };\n        } catch (e) {\n          console.warn(`无效的正则表达式: ${patternStr}`, e);\n          return null;\n        }\n      })\n      .filter(Boolean) as { id: string; pattern: RegExp; name: string; quickCheck: string }[];\n\n    return cachedPatterns;\n  };\n\n  // ===== 优化10: 酒馆正则已注册名称缓存 =====\n  const existingRegexNames = new Set<string>();\n\n  // 初始化时获取已存在的正则名称\n  const initExistingRegexes = async () => {\n    try {\n      await window.TavernHelper.updateTavernRegexesWith((regexes: TavernRegex[]) => {\n        regexes.forEach(r => existingRegexNames.add(r.script_name));\n        return regexes;\n      });\n    } catch (e) {\n      // 忽略初始化错误\n    }\n  };\n\n  // 检测消息中是否包含需要处理的表达式（带快速预检查）\n  const detectNeededRegexes = (messageContent: string): string[] => {\n    // 消息长度预检\n    if (!messageContent || messageContent.length < 3) {\n      return [];\n    }\n\n    const patterns = extractDetectionPatterns();\n    const neededIds: string[] = [];\n\n    for (const { id, pattern, name, quickCheck } of patterns) {\n      // 优化5: 使用 Set 的 has 方法 O(1) 查找 - 跳过内存中已注册的正则\n      if (registeredRegexIds.has(id)) {\n        continue;\n      }\n\n      // 优化10: 跳过酒馆中已存在的同名正则（可能有其他脚本注册）\n      if (existingRegexNames.has(name)) {\n        registeredRegexIds.add(id); // 标记为已处理，避免重复检测\n        continue;\n      }\n\n      // 快速预检查\n      if (quickCheck && !messageContent.includes(quickCheck)) {\n        continue;\n      }\n\n      try {\n        pattern.lastIndex = 0;\n        if (pattern.test(messageContent)) {\n          neededIds.push(id);\n          console.info(`自适应正则: 检测到 ${name}，准备注册`);\n        }\n      } catch (e) {\n        // 忽略正则测试错误\n      }\n    }\n\n    return neededIds;\n  };\n\n  // ===== 优化7: 批量处理函数 =====\n  let debounceTimer: ReturnType<typeof setTimeout> | null = null;\n  const pendingMessageIds = new Set<number>();\n\n  const processMessageQueue = async () => {\n    if (pendingMessageIds.size === 0) return;\n\n    const messageIds = Array.from(pendingMessageIds);\n    pendingMessageIds.clear();\n\n    // 收集所有待注册的正则ID\n    const allNeededIds = new Set<string>();\n\n    for (const message_id of messageIds) {\n      try {\n        // ===== 优化8: 直接获取消息内容而非遍历 =====\n        const messages = getChatMessages(message_id);\n        if (!messages || messages.length === 0) continue;\n\n        const messageContent = messages[0].message;\n        const neededIds = detectNeededRegexes(messageContent);\n        neededIds.forEach(id => allNeededIds.add(id));\n      } catch (error) {\n        console.error('自适应正则处理出错:', error);\n      }\n    }\n\n    // 批量注册所有需要的正则\n    if (allNeededIds.size > 0) {\n      await registerMultipleRegexes(Array.from(allNeededIds));\n    }\n  };\n\n  // 防抖包装函数\n  const debouncedProcess = (message_id: number) => {\n    pendingMessageIds.add(message_id);\n\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n    }\n\n    // 150ms 防抖延迟\n    debounceTimer = setTimeout(() => {\n      processMessageQueue();\n    }, 150);\n  };\n\n  // 注册单个正则规则（内部使用）\n  const registerSingleRegex = (regex: TavernRegex): boolean => {\n    if (registeredRegexIds.has(regex.id)) {\n      return false; // 已经注册过了\n    }\n\n    registeredRegexIds.add(regex.id);\n    return true;\n  };\n\n  // ===== 优化9: 批量注册 - 减少 await 调用次数 =====\n  const registerMultipleRegexes = async (ids: string[]): Promise<void> => {\n    const allRules = parseRegexRules();\n    const rulesToRegister: TavernRegex[] = [];\n\n    for (const id of ids) {\n      const rule = allRules.find((r: TavernRegex) => r.id === id);\n      if (rule && registerSingleRegex(rule)) {\n        rulesToRegister.push(rule);\n      }\n    }\n\n    if (rulesToRegister.length === 0) return;\n\n    // 获取已存在的正则，合并后一次性更新\n    await window.TavernHelper.updateTavernRegexesWith((regexes: TavernRegex[]) => {\n      // 移除可能存在的同名正则\n      const registeredNames = rulesToRegister.map(r => r.script_name);\n      const filtered = regexes.filter((r: TavernRegex) => !registeredNames.includes(r.script_name));\n      return [...filtered, ...rulesToRegister];\n    });\n\n    console.info(`自适应正则: 已批量注册 ${rulesToRegister.length} 条规则`);\n  };\n\n  // 移除所有已注册的正则\n  const unregisterAllRegexes = async (): Promise<void> => {\n    if (registeredRegexIds.size === 0) {\n      return;\n    }\n\n    const allRules = parseRegexRules();\n    const registeredNames = Array.from(registeredRegexIds)\n      .map(id => allRules.find((r: TavernRegex) => r.id === id)?.script_name)\n      .filter(Boolean) as string[];\n\n    await window.TavernHelper.updateTavernRegexesWith((regexes: TavernRegex[]) => {\n      return regexes.filter((r: TavernRegex) => !registeredNames.includes(r.script_name));\n    });\n\n    console.info(`自适应正则: 已移除 ${registeredNames.length} 条规则`);\n    registeredRegexIds.clear();\n  };\n\n  // 监听消息接收事件\n  eventOn(tavern_events.MESSAGE_RECEIVED, async (message_id: number) => {\n    debouncedProcess(message_id);\n  });\n\n  // 监听消息编辑事件\n  eventOn(tavern_events.MESSAGE_EDITED, async (message_id: number) => {\n    debouncedProcess(message_id);\n  });\n\n  const enabledRules = regexData.filter((r: any) => !r.disabled).length;\n  console.info(`自适应正则: 准备了 ${enabledRules} 条规则用于检测`);\n\n  // ===== 优化10: 初始化时获取酒馆中已存在的正则 =====\n  await initExistingRegexes();\n\n  // 卸载时移除所有已注册的正则\n  $(window).on('pagehide', async () => {\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n    }\n    await processMessageQueue();\n    await unregisterAllRegexes();\n    console.info('自适应正则脚本已卸载');\n  });\n});\n"],"names":["$","async","console","info","registeredRegexIds","Set","cachedPatterns","cachedTavernRules","parseRegexRules","filter","rule","disabled","map","id","script_name","scriptName","enabled","scope","find_regex","findRegex","replace_string","replaceString","trim_strings","Array","isArray","trimStrings","join","source","user_input","ai_output","slash_command","world_info","destination","display","prompt","run_on_edit","runOnEdit","min_depth","minDepth","max_depth","maxDepth","existingRegexNames","detectNeededRegexes","messageContent","length","patterns","patternStr","match","pattern","RegExp","quickCheck","includes","tagMatch","startsWith","firstTagMatch","substring","Math","min","name","e","warn","Boolean","neededIds","has","add","lastIndex","test","push","debounceTimer","pendingMessageIds","processMessageQueue","size","messageIds","from","clear","allNeededIds","message_id","messages","getChatMessages","message","forEach","error","registerMultipleRegexes","debouncedProcess","clearTimeout","setTimeout","registerSingleRegex","regex","ids","allRules","rulesToRegister","find","r","window","TavernHelper","updateTavernRegexesWith","regexes","registeredNames","eventOn","tavern_events","MESSAGE_RECEIVED","MESSAGE_EDITED","enabledRules","initExistingRegexes","on","unregisterAllRegexes"],"sourceRoot":""}