{"version":3,"file":"index.js","mappings":"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","sources":["src://tavern_helper_template/src/自适应正则脚本/index.ts"],"sourcesContent":["// 自适应正则脚本\n// 功能：AI输出完成后，检测最后一层聊天存在的表达式，将匹配的 scriptName 存入变量并排序\n// 加载脚本/变量变化时，检查角色卡正则列表与变量列表，注册缺失的正则\n// 卸载脚本时，根据列表卸载对应的正则\n// 使用防抖机制（500ms）防止无限循环\n\nimport regexData from './regex.json';\n\n$(async () => {\n  console.info('自适应正则脚本已加载');\n\n  // 聊天变量键名 - 存储当前应该注册的正则 scriptName 列表\n  const VARIABLE_KEY = 'adaptive_regex_names';\n\n  // 同步锁，防止无限循环\n  let isSyncing = false;\n  // 上次处理的聊天ID，用于防抖\n  let lastChatId: string | null = null;\n  // 防抖定时器\n  let syncTimeout: ReturnType<typeof setTimeout> | null = null;\n\n  console.info(`自适应正则: 成功加载 ${regexData.length} 条规则`);\n\n  // 从 regex.json 中获取有效的正则规则\n  const getEnabledRegexRules = (): TavernRegex[] => {\n    return regexData\n      .filter((rule: any) => !rule.disabled)\n      .map((rule: any) => ({\n        id: rule.id,\n        script_name: rule.scriptName,\n        enabled: true,\n        scope: 'character' as const,\n        find_regex: rule.findRegex,\n        replace_string: rule.replaceString,\n        trim_strings: Array.isArray(rule.trimStrings) ? rule.trimStrings.join('\\n') : '',\n        source: {\n          user_input: false,\n          ai_output: true,\n          slash_command: false,\n          world_info: false,\n        },\n        destination: {\n          display: true,\n          prompt: false,\n        },\n        run_on_edit: rule.runOnEdit ?? true,\n        min_depth: rule.minDepth ?? null,\n        max_depth: rule.maxDepth ?? 10,\n      }));\n  };\n\n  // 从 regex.json 提取检测模式（便于后续拓展）\n  const extractDetectionPatterns = (): { scriptName: string; pattern: RegExp; quickCheck: string }[] => {\n    return regexData\n      .filter((rule: any) => !rule.disabled)\n      .map((rule: any) => {\n        let patternStr = rule.findRegex;\n\n        // 解析正则表达式，去除可能的 /pattern/flags 格式\n        const match = patternStr.match(/^\\/(.+)\\/([gimsuy]*)$/);\n        if (match) {\n          patternStr = match[1];\n        }\n\n        try {\n          const pattern = new RegExp(patternStr, 'i');\n\n          let quickCheck = '';\n          if (patternStr.includes('{') || patternStr.includes('\\\\{')) {\n            quickCheck = '{';\n          } else if (patternStr.includes('<') || patternStr.includes('\\\\<')) {\n            const tagMatch = patternStr.match(/<(\\w+)/);\n            if (tagMatch) {\n              quickCheck = `<${tagMatch[1]}`;\n            }\n          } else if (patternStr.includes('\\\\[') || patternStr.includes('\\\\]')) {\n            quickCheck = '[';\n          } else if (patternStr.includes('\\\\(') || patternStr.includes('\\\\)')) {\n            quickCheck = '(';\n          } else if (patternStr.startsWith('>')) {\n            quickCheck = '>';\n          } else if (patternStr.startsWith('<')) {\n            const firstTagMatch = patternStr.match(/<(\\w+)/);\n            if (firstTagMatch) {\n              quickCheck = `<${firstTagMatch[1]}`;\n            }\n          } else {\n            quickCheck = patternStr.substring(0, Math.min(15, patternStr.length));\n          }\n\n          return {\n            scriptName: rule.scriptName,\n            pattern,\n            quickCheck,\n          };\n        } catch (e) {\n          console.warn(`无效的正则表达式: ${patternStr}`, e);\n          return null;\n        }\n      })\n      .filter(Boolean) as { scriptName: string; pattern: RegExp; quickCheck: string }[];\n  };\n\n  // 检测消息中包含的需要处理的正则 scriptName\n  // skipStoredNames: 已存储的正则名称列表，跳过这些正则的匹配检测\n  const detectNeededScriptNames = (messageContent: string, skipStoredNames: string[] = []): string[] => {\n    if (!messageContent || messageContent.length < 3) {\n      return [];\n    }\n\n    const patterns = extractDetectionPatterns();\n    const neededNames: string[] = [];\n    const skipSet = new Set(skipStoredNames);\n\n    for (const { scriptName, pattern, quickCheck } of patterns) {\n      // 跳过已存储的正则（它们已经匹配过了，不需要再次检测）\n      if (skipSet.has(scriptName)) {\n        continue;\n      }\n\n      // 快速预检查\n      if (quickCheck && !messageContent.includes(quickCheck)) {\n        continue;\n      }\n\n      try {\n        pattern.lastIndex = 0;\n        if (pattern.test(messageContent)) {\n          neededNames.push(scriptName);\n          console.info(`自适应正则: 检测到 ${scriptName}`);\n        }\n      } catch (e) {\n        // 忽略正则测试错误\n      }\n    }\n\n    return neededNames;\n  };\n\n  // 获取聊天变量中存储的正则名称列表\n  const getStoredRegexNames = (): string[] => {\n    try {\n      const chatVars = getVariables({ type: 'chat' });\n      const stored = chatVars?.[VARIABLE_KEY];\n      if (Array.isArray(stored)) {\n        return stored.filter((item): item is string => typeof item === 'string');\n      }\n    } catch (e) {\n      console.warn('获取存储的正则名称失败:', e);\n    }\n    return [];\n  };\n\n  // 保存正则名称列表到聊天变量（排序后）\n  const saveStoredRegexNames = (names: string[]): void => {\n    try {\n      // 排序保证一致性\n      const sortedNames = [...names].sort();\n      replaceVariables({ [VARIABLE_KEY]: sortedNames }, { type: 'chat' });\n      console.info(`自适应正则: 已保存 ${sortedNames.length} 个正则名称到聊天变量`);\n    } catch (e) {\n      console.warn('保存正则名称失败:', e);\n    }\n  };\n\n  // 获取角色卡当前已注册的所有正则 scriptName\n  const getCharacterCardRegexNames = async (): Promise<Set<string>> => {\n    const names = new Set<string>();\n    try {\n      const regexes = await updateTavernRegexesWith((regexes: TavernRegex[]) => {\n        regexes.forEach(r => names.add(r.script_name));\n        return regexes;\n      });\n    } catch (e) {\n      console.warn('获取角色卡正则列表失败:', e);\n    }\n    return names;\n  };\n\n  // 注册单个正则规则\n  const registerRegexRule = async (rule: TavernRegex): Promise<void> => {\n    try {\n      await updateTavernRegexesWith((regexes: TavernRegex[]) => {\n        // 避免重复注册同名正则\n        const filtered = regexes.filter((r: TavernRegex) => r.script_name !== rule.script_name);\n        return [...filtered, rule];\n      });\n    } catch (e) {\n      console.warn(`注册正则失败: ${rule.script_name}`, e);\n    }\n  };\n\n  // 同步正则列表：对比变量列表和角色卡正则列表\n  // - 移除：存在于角色卡正则列表但不在变量列表中的正则\n  // - 注册：存在于变量列表但不在角色卡正则列表中的正则\n  const syncRegexWithVariable = async (): Promise<void> => {\n    // 防止重复调用\n    if (isSyncing) {\n      console.info('自适应正则: 正在同步中，跳过本次调用');\n      return;\n    }\n\n    try {\n      isSyncing = true;\n\n      const variableNames = getStoredRegexNames();\n      const variableSet = new Set(variableNames);\n      const characterCardNames = await getCharacterCardRegexNames();\n      const characterSet = new Set(characterCardNames);\n\n      // 获取所有启用状态的 regex.json 规则名称（用于判断是否应该移除）\n      const enabledRegexNames = new Set(getEnabledRegexRules().map(r => r.script_name));\n\n      // 找出需要移除的正则（同时满足两个条件：1. 在regex.json中启用 2. 不在变量列表中）\n      const toRemove: string[] = [];\n      for (const name of characterCardNames) {\n        // 只有当该正则是在regex.json中启用着的，且不在变量列表中时才移除\n        if (!variableSet.has(name) && enabledRegexNames.has(name)) {\n          toRemove.push(name);\n        }\n      }\n\n      // 找出需要注册的正则（在变量中但不在角色卡中）\n      const toRegister: string[] = [];\n      for (const name of variableNames) {\n        if (!characterSet.has(name)) {\n          toRegister.push(name);\n        }\n      }\n\n      // 执行移除\n      if (toRemove.length > 0) {\n        await removeRegexByNames(toRemove);\n        console.info(`自适应正则: 已移除 ${toRemove.length} 条不在变量列表中的规则: ${toRemove.join(', ')}`);\n      }\n\n      // 执行注册\n      if (toRegister.length > 0) {\n        const allRules = getEnabledRegexRules();\n        let registeredCount = 0;\n        for (const name of toRegister) {\n          const rule = allRules.find(r => r.script_name === name);\n          if (rule) {\n            await registerRegexRule(rule);\n            registeredCount++;\n            console.info(`自适应正则: 已注册 ${name}`);\n          }\n        }\n        if (registeredCount > 0) {\n          console.info(`自适应正则: 共注册了 ${registeredCount} 条规则`);\n        }\n      }\n\n      if (toRemove.length === 0 && toRegister.length === 0) {\n        console.info('自适应正则: 变量列表与角色卡正则列表已同步，无需更新');\n      }\n    } catch (e) {\n      console.error('同步正则列表失败:', e);\n    } finally {\n      isSyncing = false;\n    }\n  };\n\n  // 移除指定名称的正则\n  const removeRegexByNames = async (names: string[]): Promise<void> => {\n    if (names.length === 0) return;\n\n    try {\n      await updateTavernRegexesWith((regexes: TavernRegex[]) => {\n        return regexes.filter((r: TavernRegex) => !names.includes(r.script_name));\n      });\n      console.info(`自适应正则: 已移除 ${names.length} 条规则`);\n    } catch (e) {\n      console.warn('移除正则失败:', e);\n    }\n  };\n\n  // 扫描最后一层消息并更新变量\n  const scanAndUpdateVariable = async (): Promise<void> => {\n    try {\n      console.info('自适应正则: 开始扫描最后一层消息');\n\n      const messages = getChatMessages(-1); // 获取最后一条消息\n      console.info('自适应正则: 获取到的消息:', messages);\n\n      if (!messages || messages.length === 0) {\n        console.info('自适应正则: 没有找到消息，返回');\n        return;\n      }\n\n      const lastMessage = messages[0];\n      const messageContent = lastMessage.message;\n      console.info('自适应正则: 消息内容:', messageContent);\n\n      // 获取已存储的名称，用于跳过检测\n      const storedNames = getStoredRegexNames();\n      console.info('自适应正则: 已存储的正则名称:', storedNames);\n\n      // 检测需要的正则名称（跳过已存储的正则）\n      const detectedNames = detectNeededScriptNames(messageContent, storedNames);\n      console.info('自适应正则: 检测到的新正则名称:', detectedNames);\n\n      // 合并并去重\n      const combinedNames = [...new Set([...storedNames, ...detectedNames])];\n      console.info('自适应正则: 合并后的正则名称:', combinedNames);\n\n      // 如果有变化，保存并同步\n      const storedSorted = [...storedNames].sort().join(',');\n      const combinedSorted = [...combinedNames].sort().join(',');\n      console.info('自适应正则: 排序后的存储名称:', storedSorted);\n      console.info('自适应正则: 排序后的合并名称:', combinedSorted);\n\n      if (storedSorted !== combinedSorted) {\n        console.info(`自适应正则: 检测到变化，从 ${storedNames.length} 个更新到 ${combinedNames.length} 个`);\n        saveStoredRegexNames(combinedNames);\n        await syncRegexWithVariable();\n      } else {\n        console.info('自适应正则: 无变化，不更新');\n      }\n    } catch (e) {\n      console.error('扫描消息更新变量失败:', e);\n    }\n  };\n\n  // 初始化：根据变量中的列表注册缺失的正则\n  const initializeFromVariable = async (): Promise<void> => {\n    const storedNames = getStoredRegexNames();\n    if (storedNames.length > 0) {\n      console.info(`自适应正则: 初始化，从变量加载 ${storedNames.length} 个正则`);\n      await syncRegexWithVariable();\n    } else {\n      // 如果变量为空，扫描当前消息\n      console.info('自适应正则: 变量为空，扫描当前消息');\n      await scanAndUpdateVariable();\n    }\n  };\n\n  // 监听变量变化的事件回调\n  let previousStoredNames: string[] = [];\n\n  const watchVariableChange = (): void => {\n    // 初始记录\n    previousStoredNames = getStoredRegexNames();\n\n    // 重写 replaceVariables 函数来监听变量变化\n    const originalReplaceVariables = replaceVariables;\n    (window as any).replaceVariables = function (variables: Record<string, any>, option: any) {\n      const result = originalReplaceVariables.call(this, variables, option);\n\n      // 检查是否是聊天变量发生变化，且不在同步中\n      if (!isSyncing && (option?.type === 'chat' || !option)) {\n        const currentStoredNames = getStoredRegexNames();\n        const currentSorted = [...currentStoredNames].sort().join(',');\n        const previousSorted = [...previousStoredNames].sort().join(',');\n\n        if (currentSorted !== previousSorted) {\n          console.info(`自适应正则: 变量发生变化，刷新正则列表`);\n          // 使用防抖，避免频繁触发\n          if (syncTimeout) {\n            clearTimeout(syncTimeout);\n          }\n          syncTimeout = setTimeout(() => {\n            syncRegexWithVariable().then(() => {\n              previousStoredNames = getStoredRegexNames();\n            });\n          }, 500);\n        }\n      }\n\n      return result;\n    };\n  };\n\n  // 监听新消息事件（AI输出完成时）\n  eventOn(tavern_events.MESSAGE_RECEIVED, async (messageId: number) => {\n    console.info(`自适应正则: 收到新消息 ${messageId}，扫描最新楼层`);\n    await scanAndUpdateVariable();\n  });\n\n  // 监听聊天切换事件（带防抖）\n  eventOn(tavern_events.CHAT_CHANGED, async (chatFileName: string) => {\n    console.info(`自适应正则: 检测到聊天切换到 ${chatFileName}`);\n\n    // 忽略相同的聊天ID\n    if (lastChatId === chatFileName) {\n      return;\n    }\n    lastChatId = chatFileName;\n\n    // 清除之前的定时器\n    if (syncTimeout) {\n      clearTimeout(syncTimeout);\n    }\n\n    // 防抖：延迟 500ms 执行同步\n    syncTimeout = setTimeout(async () => {\n      if (!isSyncing) {\n        await syncRegexWithVariable();\n      }\n    }, 500);\n  });\n\n  // 卸载时移除所有本脚本注册的正则\n  $(window).on('pagehide', async () => {\n    const storedNames = getStoredRegexNames();\n    if (storedNames.length > 0) {\n      await removeRegexByNames(storedNames);\n      console.info(`自适应正则: 已卸载 ${storedNames.length} 条规则`);\n    }\n    console.info('自适应正则脚本已卸载');\n  });\n\n  // 启动\n  console.info('自适应正则: 启动初始化');\n  await initializeFromVariable();\n  watchVariableChange();\n\n  const enabledRules = regexData.filter((r: any) => !r.disabled).length;\n  console.info(`自适应正则: 准备了 ${enabledRules} 条规则用于检测`);\n});\n"],"names":["$","async","console","info","VARIABLE_KEY","isSyncing","lastChatId","syncTimeout","length","getEnabledRegexRules","filter","rule","disabled","map","id","script_name","scriptName","enabled","scope","find_regex","findRegex","replace_string","replaceString","trim_strings","Array","isArray","trimStrings","join","source","user_input","ai_output","slash_command","world_info","destination","display","prompt","run_on_edit","runOnEdit","min_depth","minDepth","max_depth","maxDepth","detectNeededScriptNames","messageContent","skipStoredNames","patterns","patternStr","match","pattern","RegExp","quickCheck","includes","tagMatch","startsWith","firstTagMatch","substring","Math","min","e","warn","Boolean","neededNames","skipSet","Set","has","lastIndex","test","push","getStoredRegexNames","chatVars","getVariables","type","stored","item","registerRegexRule","updateTavernRegexesWith","regexes","r","syncRegexWithVariable","variableNames","variableSet","characterCardNames","names","forEach","add","getCharacterCardRegexNames","characterSet","enabledRegexNames","toRemove","name","toRegister","removeRegexByNames","allRules","registeredCount","find","error","scanAndUpdateVariable","messages","getChatMessages","message","storedNames","detectedNames","combinedNames","storedSorted","sort","combinedSorted","sortedNames","replaceVariables","saveStoredRegexNames","previousStoredNames","eventOn","tavern_events","MESSAGE_RECEIVED","messageId","CHAT_CHANGED","chatFileName","clearTimeout","setTimeout","window","on","initializeFromVariable","originalReplaceVariables","variables","option","result","call","this","then","watchVariableChange","enabledRules"],"sourceRoot":""}